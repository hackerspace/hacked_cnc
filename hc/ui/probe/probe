#!/usr/bin/python

import sys
import time

#INIT
import os
os.environ['QT_API'] = 'pyqt5'
#/INIT

# TODO:
# model for commands
# separate history

from PyQt5 import QtGui
from PyQt5.QtCore import pyqtSlot, QTimer, Qt
from PyQt5.QtGui import QColor, QTextCursor
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QFileDialog, QTreeWidgetItem, QHeaderView
from PyQt5.uic import loadUi
from PyQt5.QtNetwork import QTcpSocket, QAbstractSocket

from hc import parse
from hc.util import enc_msg, dec_msg
from hc.command import Command

import Queue



class QHcClient(QTcpSocket):
    n = 0

    def __init__(self, *args):
        super(QHcClient, self).__init__(*args)
        self.waitForReadyRead(100)
        self.setSocketOption(QAbstractSocket.LowDelayOption, 1)
        self.setSocketOption(QAbstractSocket.KeepAliveOption, 1)

        self.queue = Queue.PriorityQueue()

    def cmd(self, cmd):
        ec = cmd.encode('ascii')
        msg = enc_msg(ec, self.n)
        self.n += 1
        self.write(msg)

        #print(msg)
        #self.waitForBytesWritten(-1)

    # FIXME: unused
    def send_next(self):
        try:
            msg = self.queue.get_nowait()
        except Queue.Empty:
            return

        QTimer.singleShot(0, self.send_next)



red = QColor(200, 0, 0)
green = QColor(0, 200, 0)
blue = QColor(0, 0, 200)

probecmd = 'G30 F100'

class Main(QMainWindow):
    current_x = 0.
    current_y = 0.
    current_z = 0.

    def __init__(self, *args):
        super(Main, self).__init__(*args)

        loadUi('mainwindow.ui', self)

        self.host.setText("localhost")
        self.port.setText("11011")
        #self.prompt.setText("M114")
        self.prompt.addItem("M114")
        self.prompt.addItem("MULTILINE")

        #self.conn = QTcpSocket(self)
        self.conn = QHcClient(self)
        self.conn.readyRead.connect(self.readSocket)
        self.conn.error.connect(self.socketError)
        self.conn.connected.connect(self.socketConnect)
        self.conn.disconnected.connect(self.socketDisconnect)

        self.connected = False

        self.actionSave.triggered.connect(self.do_save)
        self.actionSave_probe_data.triggered.connect(self.save_probe_data_dialog)
        self.actionLoad_probe_data.triggered.connect(self.load_probe_data_dialog)

        self.prompt.setFocus()
        self.prompt.lineEdit().returnPressed.connect(self.on_send_clicked)

        self.do_connect()
        self.update_probe()

        #self.commodel = QStandardItemModel(self.comlist)
        #self.comlist.setModel(self.commodel)
        self.comtree.setColumnCount(3)
        self.comtree.setColumnWidth(0, 180)
        self.comtree.setColumnWidth(1, 350)
        self.comtree.setHeaderLabels(['Time', 'Command', 'Response'])
        #self.comtree.header().setSectionResizeMode(2, QHeaderView.Stretch)
        self.comtree.header().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.comtree.header().setStretchLastSection(False)

        # prefill probe width / height
        #self.probe_area_width.setValue(self.gl.objsize[0])
        #self.probe_area_height.setValue(self.gl.objsize[1])

    def choose_gcode(self):
        d = QFileDialog(self)
        d.setNameFilter("GCode (*.ngc *.gcode);;All files (*.*)")
        d.exec_()
        name = d.selectedFiles()[0]
        try:
            open(name, 'r').close()
            self.gl.loadGCode(name)
        except IOError:
            pass

    def append(self, text):
        self.text.append(text)

        if self.autoscroll.isChecked():
            c = self.text.textCursor()
            c.movePosition(QTextCursor.End, QTextCursor.MoveAnchor)
            self.text.setTextCursor(c)

    def handle_response(self, idx, txt):
        root = self.comtree.invisibleRootItem()
        item = root.child(idx)

        item.setText(0, time.strftime("%Y.%m.%d. %H:%M:%S", time.localtime()))
        if not txt:
            txt = 'ok'
        item.setText(2, txt)
        #item.setBackground(0, QtGui.QBrush(green))
        item.setCheckState(0, Qt.Checked)
        self.comtree.scrollToItem(item)

        cmd = item.text(1)

        if 'G0' in cmd:
            x, y, z = parse.xyz(cmd[2:])
            # should probably emit signals

            self.current_x = x
            self.current_y = y
            self.current_z = z

        if 'G30' in cmd:
            z, c = parse.probe(txt)
            self.gl.proberes.probe_results.append((self.current_x, self.current_y, z))
            self.gl.proberes.update_results()

    def save_probe_data_dialog(self):
        if not self.gl.proberes.probe_results:
            # err not much to save
            return

        fname, sel = QFileDialog.getSaveFileName(
            self,
            'Save Log',)
            #'/path/to/default/directory', FIXME: lastused
            #selectedFilter='*.txt')

        if fname:
            self.save_probe_data(self, fname)

    def save_probe_data(self, fname):
        with open(fname, 'w') as f:
            for x, y, z in self.gl.proberes.probe_results:
                f.write("{:04.2f} {:04.2f} {:04.2f}\n".format(x, y, z))

    def load_probe_data_dialog(self):
        d = QFileDialog(self)
        d.setNameFilter("Log data (*.txt *.log);;All files (*.*)")
        d.exec_()
        fname = d.selectedFiles()[0]
        if fname:
            self.load_probe_data(fname)

    def load_probe_data(self, fname):
        with open(fname, 'r') as f:
            d = (map(lambda x: map(float, x.split()), f.readlines()))

        self.gl.proberes.probe_results = d
        self.gl.proberes.update_results()

    @pyqtSlot()
    def on_save_clicked(self):
        root = self.comtree.invisibleRootItem()
        count = root.childCount()

        parts = []
        for i in range(count):
            item = root.child(i)
            time = item.text(0)
            cmd = item.text(1)
            resp = item.text(2)
            parts.append((time, cmd, resp))

        fname, sel = QFileDialog.getSaveFileName(
            self,
            'Save Log',)
            #'/path/to/default/directory', FIXME: lastused
            #selectedFilter='*.txt')

        if fname:
            with open(fname, 'w+') as f:
                for time, cmd, resp in parts:
                    f.write('{}\t{}\t{}\n'.format(time, cmd, resp))

    def readSocket(self):

        def handle(r):
            if not r:
                return

            print('buffered', r)
            (idx, txt) = dec_msg(r)
            if idx is not None:
                self.handle_response(idx, txt)

        buffer = ''

        while True:
            r = str(self.conn.readLine())

            if not r:
                handle(buffer)
                if self.conn.canReadLine():
                    buffer = ''
                    continue

                break

            if r[0] == '[':
                handle(buffer)
                buffer = r
                continue

            buffer += r

    def readMonitor(self):
            for chunk in txt.splitlines():
                if chunk:
                    if chunk[0] == '<':
                        self.text.setTextColor(QColor(200, 0, 0))
                    elif chunk[0] == '>':
                        self.text.setTextColor(QColor(0, 200, 0))
                    else:
                        self.text.setTextColor(QColor(0, 0, 200))

                    self.append(chunk)

    def info(self, errtext):
        self.text.setTextColor(QColor(20, 20, 20))
        self.append(errtext)

    def err(self, errtext):
        self.text.setTextColor(QColor(100, 0, 0))
        self.append(errtext)

    def socketDisconnect(self):
        self.connected = False
        self.err("Disconnected")

    def socketConnect(self):
        self.connected = True
        self.info("Connected")

    def socketError(self, socketError):
        if socketError == QAbstractSocket.RemoteHostClosedError:
            pass
        elif socketError == QAbstractSocket.HostNotFoundError:
            self.err("The host was not found. Please check the host name and "
                     "port settings.")

        elif socketError == QAbstractSocket.ConnectionRefusedError:
            self.err("The connection was refused by the peer. Make sure the "
                     "server is running, and check that the host name "
                     "and port settings are correct.")
        else:
            self.err("The following error occurred: {0}"
                     .format(self.conn.errorString()))

    def do_save(self):
        fname, sel = QFileDialog.getSaveFileName(
            self,
            'Save Log',)
            #'/path/to/default/directory', FIXME: lastused
            #selectedFilter='*.txt')

        if fname:
            with open(fname, 'w+') as f:
                f.write(self.text.toPlainText())

    def do_connect(self):
        self.conn.abort()
        self.conn.connectToHost(self.host.text(),
                                int(self.port.text()))

    @pyqtSlot()
    def on_connect_clicked(self):
        self.do_connect()
        self.prompt.setFocus()

    @pyqtSlot()
    def on_prompt_activated(self):
        print("LAA")

    def run_cmd(self, cmd):
        item = QTreeWidgetItem(self.comtree)

        item.setText(0, time.strftime("%Y.%m.%d. %H:%M:%S", time.localtime()))
        item.setText(1, cmd)

        for i in range(3):
            item.setTextAlignment(i, Qt.AlignTop)

        item.setForeground(1, QtGui.QBrush(blue))
        item.setForeground(1, QtGui.QBrush(green))
        item.setForeground(2, QtGui.QBrush(red))

        self.comtree.scrollToItem(item)
        self.conn.cmd(cmd)

    @pyqtSlot()
    def on_send_clicked(self):
        if not self.connected:
            self.err("Not connected")
            return
        out = self.prompt.currentText()
        self.run_cmd(out)

    def gen_probe_grid(self, rows, cols, w, h, x_margin, y_margin, start_z):
        w = w - x_margin * 2.
        h = h - y_margin * 2.

        if rows <= 0 or cols <= 0:
            return []

        if cols == 1 or rows == 1:
            # FIXME: finish this cornercase
            return []

        xstep = w / (cols - 1)
        ystep = h / (rows - 1)

        cx = x_margin
        cy = y_margin

        out = []

        for i in range(rows):
            for j in range(cols):
                out.append((cx, cy, start_z))
                cx += xstep

            cx = x_margin
            cy += ystep

        return out

    def get_probe_points(self):
        probe_points = self.gen_probe_grid(
            self.probe_rows.value(), self.probe_cols.value(),
            self.probe_area_width.value(), self.probe_area_height.value(),
            self.probe_margin.value(), self.probe_margin.value(),
            self.probe_start_z.value())

        return probe_points

    def find_surface(self):
        self.run_cmd(probecmd)

    @pyqtSlot()
    def on_run_probe_clicked(self):
        # clean probe result
        self.gl.proberes.probe_results = []

        def xyzfmt(x, y, z):
            return 'X{:04.2f} Y{:04.2f} Z{:04.2f}'.format(x, y, z)

        probe_points = self.get_probe_points()
        for point in probe_points:
            self.run_cmd('G0 {}'.format(xyzfmt(*point)))
            self.run_cmd(probecmd)

    def update_probe(self):
        probe_points = self.get_probe_points()
        self.gl.probelist.probe_points = probe_points
        self.gl.probelist.update()

    @pyqtSlot()
    def on_probe_clicked(self):
        self.update_probe()

app = QApplication(sys.argv)
widget = Main()
widget.show()
sys.exit(app.exec_())
